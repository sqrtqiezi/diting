# Feature Specification: 微信消息持久化存储机制

**Feature Branch**: `006-message-storage`
**Created**: 2025-11-09
**Status**: Draft
**Input**: User description: "设计消息存储机制
1. 当前 webhook 消息混在日志中输出,现在需要为其设计单独的存储机制
2. 根据微信消息特点设置存储机制。需要长期保存,且方便根据主题和特点分析消息"

## Assumptions

- 根据历史数据(52,554条消息),系统每天约接收2,000-5,000条消息
- 消息数据需要长期保存(至少1年),用于主题分析和数据挖掘
- 消息查询主要场景:按时间范围、消息类型、发送者/接收者、群聊ID检索
- 存储系统需要支持结构化查询,而非仅文本搜索
- 日志系统继续保留,用于系统运维和故障排查,与消息存储并行
- 系统资源有限,优先考虑轻量级存储方案
- 消息数据不涉及敏感的财务或支付信息,但包含个人通信内容
- 存储系统需要支持并发写入(多个webhook实例)

## User Scenarios & Testing

### User Story 1 - 消息持久化存储 (Priority: P1)

作为系统管理员,我需要将接收到的所有微信消息自动保存到持久化存储中,以便消息不会因日志轮转而丢失,确保数据长期可用。

**Why this priority**: 这是消息存储的核心功能。当前消息混在日志中,日志轮转(100MB × 10个文件)会导致旧消息丢失,无法满足长期保存需求。这是后续所有分析功能的基础。

**Independent Test**: 启动服务后发送测试消息,验证消息是否成功写入存储,并能在一周后仍能查询到该消息。可以独立测试存储功能,不依赖后续的查询和分析功能。

**Acceptance Scenarios**:

1. **Given** webhook服务接收到消息通知(notify_type=1010), **When** 消息处理完成, **Then** 消息的所有字段(guid、notify_type、data内的所有字段)都被完整保存到存储中
2. **Given** webhook服务接收到联系人更新通知(notify_type=1200), **When** 消息处理完成, **Then** 联系人信息被正确保存,包括用户名、昵称、头像等所有字段
3. **Given** 系统存储了1个月的历史消息, **When** 查询1个月前的消息, **Then** 能够成功检索到完整的消息数据
4. **Given** 存储写入过程中发生错误(如磁盘空间不足), **When** 错误发生, **Then** 系统记录错误日志,webhook继续处理后续消息不中断

---

### User Story 2 - 消息快速检索 (Priority: P2)

作为数据分析人员,我需要根据时间范围、消息类型、用户ID等条件快速检索消息,以便进行主题分析和用户行为研究。

**Why this priority**: 存储的价值在于能够高效查询。虽然不如存储本身紧迫,但快速检索是消息分析的前提,直接影响数据利用效率。

**Independent Test**: 在存储中准备10,000条测试消息,执行各种查询条件(时间范围、消息类型、用户ID),验证查询响应时间在合理范围内(3秒内),结果准确完整。

**Acceptance Scenarios**:

1. **Given** 存储中有10,000+条消息, **When** 按时间范围查询(如最近7天), **Then** 查询结果在3秒内返回,包含该时间段内的所有消息
2. **Given** 存储中有多种消息类型, **When** 查询特定消息类型(如msg_type=49应用消息), **Then** 返回该类型的所有消息,无遗漏
3. **Given** 存储中有个人消息和群聊消息, **When** 查询特定群聊ID的消息, **Then** 返回该群聊的所有消息,包含发送者信息
4. **Given** 需要查询特定发送者的消息, **When** 按from_username查询, **Then** 返回该用户发送的所有消息,按时间排序

---

### User Story 3 - 消息统计与分析 (Priority: P3)

作为业务分析人员,我需要对消息数据进行统计分析(如消息类型分布、活跃用户Top 10、群聊活跃度),以便了解消息使用模式和用户行为特征。

**Why this priority**: 统计分析是数据价值的进一步挖掘,优先级低于基础存储和检索。可以在存储和检索功能稳定后再实现,不影响核心数据收集。

**Independent Test**: 基于现有存储的消息数据,执行聚合查询(如统计最近30天的消息类型分布),验证统计结果准确性和查询性能。

**Acceptance Scenarios**:

1. **Given** 存储中有30天的消息数据, **When** 统计消息类型分布, **Then** 返回每种消息类型的数量和占比,与实际数据一致
2. **Given** 存储中有多个用户的消息, **When** 查询最活跃的10个用户(按消息数量), **Then** 返回正确的用户列表和消息数量
3. **Given** 存储中有多个群聊的消息, **When** 分析群聊活跃度(按消息数量和时间范围), **Then** 返回群聊活跃度排名和趋势数据
4. **Given** 需要分析消息时间分布, **When** 按小时统计消息数量, **Then** 返回24小时消息分布图数据

---

### User Story 4 - 存储空间管理 (Priority: P4)

作为系统管理员,我需要监控存储空间使用情况,并能够配置数据保留策略(如保留1年后自动归档或删除),以便在存储容量和数据价值之间取得平衡。

**Why this priority**: 空间管理是长期运维需求,短期内(数据量小时)不紧迫。可以在数据积累到一定量后再实现自动化清理策略。

**Independent Test**: 配置保留策略(如保留365天),运行清理任务,验证超过保留期的数据被正确删除或归档,近期数据不受影响。

**Acceptance Scenarios**:

1. **Given** 配置了消息保留期为365天, **When** 定期清理任务运行, **Then** 超过365天的消息被删除或归档,不影响近期数据
2. **Given** 存储空间使用接近预设阈值(如80%), **When** 检查存储状态, **Then** 系统发出告警,提示管理员采取行动
3. **Given** 需要查看存储使用情况, **When** 查询存储统计信息, **Then** 返回总消息数、存储大小、增长趋势等指标
4. **Given** 历史数据需要归档, **When** 执行归档操作, **Then** 指定时间范围的数据被导出到文件,可以从存储中移除

---

### Edge Cases

- **并发写入冲突**: 多个webhook实例同时写入同一条消息(重复推送)时,通过消息ID(msg_id)去重,只保留一条记录
- **大消息处理**: 消息内容超大(如视频消息content字段)时,正常保存完整内容,依赖存储系统的字段大小限制
- **存储不可用**: 存储系统暂时不可用(如SQLite文件被锁定)时,webhook记录错误日志但不阻塞消息接收,消息暂存在内存队列,待存储恢复后重试写入
- **数据迁移**: 当需要更换存储方案(如从SQLite迁移到PostgreSQL)时,提供数据导出/导入工具,支持全量迁移
- **查询性能降级**: 当存储数据量超过100万条时,查询性能可能下降,通过添加索引(时间、消息类型、用户ID)优化查询
- **不完整的消息**: 接收到格式异常的消息(缺少必需字段)时,保存原始JSON到一个特殊字段(raw_data),标记为解析失败

## Requirements

### Functional Requirements

- **FR-001**: 系统必须将每条接收到的微信消息持久化存储,包含guid、notify_type和data的所有字段
- **FR-002**: 系统必须为每条消息自动添加接收时间戳(精确到秒),用于时间范围查询
- **FR-003**: 系统必须支持通过消息ID(msg_id)去重,防止重复消息被多次存储
- **FR-004**: 系统必须支持按时间范围查询消息(如2025-01-01至2025-01-31)
- **FR-005**: 系统必须支持按消息类型(msg_type)过滤查询,包括文本、图片、视频等所有类型
- **FR-006**: 系统必须支持按发送者(from_username)和接收者(to_username)查询消息
- **FR-007**: 系统必须支持按群聊ID(chatroom)查询群聊消息
- **FR-008**: 系统必须支持组合查询条件(如时间范围 + 消息类型 + 群聊ID)
- **FR-009**: 系统必须在存储写入失败时记录详细错误信息,但不中断webhook消息接收流程
- **FR-010**: 系统必须提供消息统计功能,支持按消息类型、用户、群聊聚合统计
- **FR-011**: 系统必须支持查询结果分页(如每页100条),避免大结果集内存溢出
- **FR-012**: 系统必须支持导出指定时间范围或查询条件的消息到JSON文件,用于数据备份或迁移
- **FR-013**: 系统必须在消息解析失败时保存原始JSON数据,便于后续排查和修复
- **FR-014**: 系统必须提供存储健康检查接口,用于监控存储系统可用性
- **FR-015**: 系统必须支持配置数据保留策略(保留天数),用于自动清理过期数据

### Key Entities

- **存储消息记录 (Stored Message Record)**: 持久化存储的消息实体,包含以下核心字段:
  - 接收时间戳 (received_at): 消息接收时间,用于时间范围查询和排序
  - 全局唯一标识 (guid): 微信实例GUID
  - 通知类型 (notify_type): 1010消息/1200联系人更新/1201删除/1202详情
  - 消息ID (msg_id): 消息唯一标识,用于去重(仅notify_type=1010)
  - 消息类型 (msg_type): 1文本/3图片/49链接等,用于类型过滤
  - 发送者 (from_username): 消息发送者ID,用于用户查询
  - 接收者 (to_username): 消息接收者ID
  - 群聊标识 (is_chatroom_msg, chatroom): 是否群聊消息及群聊ID,用于群聊分析
  - 消息内容 (content): 消息文本或数据内容
  - 完整数据 (full_data): 原始JSON数据,保留所有字段供后续分析
  - 解析状态 (parse_status): 成功/失败,标记数据质量

- **查询条件 (Query Criteria)**: 消息检索的过滤条件组合,支持:
  - 时间范围: 起始时间和结束时间
  - 消息类型: 单个或多个msg_type
  - 用户条件: from_username和/或to_username
  - 群聊条件: chatroom ID
  - 分页参数: 偏移量和每页数量

- **统计结果 (Statistics Result)**: 消息聚合分析结果,包括:
  - 消息类型分布: 每种类型的数量和占比
  - 用户活跃度: 用户ID和消息数量排名
  - 群聊活跃度: 群聊ID和消息数量
  - 时间分布: 按小时/天/周的消息数量

## Success Criteria

### Measurable Outcomes

- **SC-001**: 消息写入成功率达到99.9%,即10,000条消息中写入失败不超过10条
- **SC-002**: 单条消息写入延迟不超过100毫秒,不影响webhook响应速度
- **SC-003**: 支持至少1年的消息数据存储(约100万条消息,按每天3,000条计算)
- **SC-004**: 时间范围查询(1个月数据)响应时间不超过3秒
- **SC-005**: 消息类型/用户/群聊查询响应时间不超过2秒
- **SC-006**: 统计分析查询(如30天消息类型分布)响应时间不超过5秒
- **SC-007**: 数据分析人员能够在10分钟内完成一次完整的消息主题分析(从查询到得出结论)
- **SC-008**: 存储系统在包含100万条消息后,查询性能不降低超过50%(相比1万条消息时)
- **SC-009**: 数据导出功能能够在5分钟内导出10万条消息到JSON文件
- **SC-010**: 系统运行1个月后,存储空间使用符合预期(每万条消息约50-100MB)

## Constraints

- **技术约束**: 优先使用Python生态轻量级存储方案,与现有FastAPI/structlog技术栈兼容
- **性能约束**: 查询响应时间需在用户可接受范围(3-5秒),不要求实时响应
- **资源约束**: 存储方案需考虑单机部署场景,不依赖外部复杂数据库集群
- **兼容性约束**: 存储schema需与现有的Pydantic模型(wechat_message_schema.py)保持一致
- **可维护性约束**: 存储系统需简单易维护,避免引入过多运维复杂度

## Dependencies

- **上游依赖**: 003-wechat-notification-webhook功能(webhook服务和消息接收)必须已实现并稳定运行
- **数据依赖**: 依赖src/models/wechat_message_schema.py中的消息数据模型定义
- **技术依赖**: 需要选择合适的存储方案(如SQLite、DuckDB等),与Python 3.12.6和现有依赖兼容
